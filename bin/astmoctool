#!/usr/bin/env perl

use strict;

use IO::File;

use Astro::FITS::CFITSIO;
use Starlink::AST;

moc_tool(@ARGV);

sub moc_tool {
    my @args = @_;

    my $moc = undef;
    my $initialize_moc = sub {
        my $options = shift // '';
        $moc = new Starlink::AST::Moc($options);
    };

    # Note: currently all operations are performed at the "MaxOrder" of the
    # first loaded MOC or specified by --max-order.  Smaller cells are ignored.

    my %command = map {my ($opts, $func) = @$_; map {$_ => $func} @$opts} (
        [[qw/--info -i/], sub {
            die 'A MOC has not yet been defined' unless defined $moc;
            printf "Max. order: %i (%f\")\n", $moc->GetI('MaxOrder'), $moc->GetD('MaxRes');
            printf "Min. order: %i (%f\")\n", $moc->GetI('MinOrder'), $moc->GetD('MinRes');
            printf "Area: %f sq. deg.\n", $moc->GetD('MocArea') / 3600.0;
            printf "Cells: %i\n", $moc->GetI('MocLength');
            printf "Type: %i-byte\n", $moc->GetI('MocType');
        }],
        [[qw/--output -o/], sub {
            my $filename = shift @args;
            die 'No output filename specified' unless defined $filename;
            die "Output file '$filename' already exists" if -e $filename;
            die 'A MOC has not yet been defined' unless defined $moc;
            write_moc($moc, $filename);
        }],
        [[qw/--intersection/], sub {
            my $filename = shift @args;
            die 'No intersection filename specified' unless defined $filename;
            die 'A MOC has not yet been defined' unless defined $moc;
            read_moc($moc, $filename, Starlink::AST::Region::AST__AND(),  0);
        }],
        [[qw/--subtract/], sub {
            my $filename = shift @args;
            die 'No subtraction filename specified' unless defined $filename;
            die 'A MOC has not yet been defined' unless defined $moc;
            read_moc($moc, $filename, Starlink::AST::Region::AST__AND(),  1);
        }],
        [[qw/--show/], sub {
            die 'A MOC has not yet been defined' unless defined $moc;
            $moc->Show();
        }],
        [[qw/--max-order/], sub {
            my $max_order = shift @args;
            die 'No maximum order specified' unless defined $max_order;
            die 'Maximum order must be between 0 and 27'
                if $max_order < 0 or $max_order > 27;
            die 'Can not set maximum order: a MOC has already been defined'
                if defined $moc;
            $initialize_moc->(sprintf 'MaxOrder=%i', $max_order);
        }],
    );

    while (scalar @args) {
        my $arg = shift @args;

        if (exists $command{$arg}) {
            $command{$arg}->();
        }
        elsif (-e $arg) {
            $initialize_moc->() unless defined $moc;
            read_moc($moc, $arg, Starlink::AST::Region::AST__OR(),  0);
        }
        else {
            die "File or command '$arg' not found";
        }
    }
};

sub write_moc {
    my ($moc, $filename) = @_;

    if ($filename =~ /\.fits?$/i) {
        # MOC FITS writing routine based on "atl_mocft.f".

        my $data = $moc->GetMocData();
        my $fc = $moc->GetMocHeader();
        my $status = 0;
        my $fptr = Astro::FITS::CFITSIO::create_file($filename, $status);
        die 'Error opening FITS file' if $status;

        $fptr->insert_key_log('SIMPLE', 1, '', $status);
        $fptr->insert_key_lng('BITPIX', 8, '', $status);
        $fptr->insert_key_lng('NAXIS', 0, '', $status);
        $fptr->insert_key_log('EXTEND', 1, '', $status);
        die 'Error writing primary headers' if $status;

        $fptr->create_hdu($status);
        die 'Error creating HDU' if $status;

        $fc->Clear('Card');
        for (;;) {
            last unless $fc->FindFits('%f', my $card, 1);
            $fptr->write_record($card, $status);
        }
        die 'Error writing MOC headers' if $status;

        my $type = $moc->GetI('MocType');
        if ($type == 4) {
            $fptr->write_col_lng(1, 1, 1, (scalar @$data), $data, $status);
        }
        elsif ($type == 8) {
            $fptr->write_col_lnglng(1, 1, 1, (scalar @$data), $data, $status);
        }
        else {
            die 'MOC type not recognized';
        }
        die 'Error writing MOC data' if $status;

        $fptr->close_file($status);
        die 'Error closing FITS file' if $status;
    }
    elsif ($filename eq '-') {
        print $moc->GetMocString(0), "\n";
    }
    else {
        my $json = $filename =~ /\.json$/i;

        my $fh = new IO::File($filename, 'w');
        die "Could not open file '$filename' for writing" unless defined $fh;
        print $fh $moc->GetMocString($json ? 1 : 0);
        close $fh;
    }
}

sub read_moc{
    my ($moc, $filename, $mode, $negate) = @_;

    if ($filename =~ /\.fits?$/i) {
        # MOC FITS reading routine based on similar code in GAIA.

        my $status = 0;
        my $fptr = Astro::FITS::CFITSIO::open_file(
            $filename, Astro::FITS::CFITSIO::READONLY(), $status);
        die 'Error opening FITS file' if $status;

        $fptr->get_num_hdus(my $nhdu, $status);
        die 'Error getting number of HDUs' if $status;

        # Assume simple MOC file: only one extension which is the MOC.
        die 'Unexpected number of HDUs' unless $nhdu = 2;
        my $ihdu = 2;

        $fptr->movabs_hdu($ihdu, my $hdutype, $status);
        die 'Error selecting HDU' if $status;
        die 'HDU is not a binary table'
            unless $hdutype == Astro::FITS::CFITSIO::BINARY_TBL();

        $fptr->read_key(Astro::FITS::CFITSIO::TINT(),
            'MOCORDER', my $mocorder, my $mocorder_comment, $status);
        die 'Error reading MOCORDER' if $status;

        $fptr->read_key(Astro::FITS::CFITSIO::TINT(),
            'NAXIS2', my $moclen, my $moclen_comment, $status);
        die 'Error reading NAXIS2' if $status;

        $fptr->read_key(Astro::FITS::CFITSIO::TSTRING(),
            'TFORM1', my $tform1, my $tform1_comment, $status);
        die 'Error reading TFORM1' if $status;

        my @data;
        if ($tform1 =~ /^1?J$/) {
            $fptr->read_col_lng(1, 1, 1, $moclen, 0, \@data, my $anynull, $status);
        }
        elsif ($tform1 =~ /^1?K$/) {
            $fptr->read_col_lnglng(1, 1, 1, $moclen, 0, \@data, my $anynull, $status);
        }
        else {
            die 'Unrecognized TFORM1';
        }
        die 'Error reading MOC data' if $status;

        $moc->AddMocData($mode, $negate, $mocorder, \@data);

        $fptr->close_file($status);
        die 'Error closing FITS file' if $status;
    }
    else {
        local $/;
        my $fh = new IO::File($filename);
        die "Could not open file '$filename' for reading" unless defined $fh;
        my $buff = <$fh>;
        close $fh;

        $moc->AddMocString($mode, $negate, -1, $buff);
    }
}
